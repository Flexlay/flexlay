# Flexlay - A Generic 2D Game Editor
# Copyright (C) 2014 Ingo Ruhnke <grumbel@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


from flexlay.util import get_value_from_tree, sexpr_filter

from .sector import Sector
from .gameobj import PathNode, BadGuy
from .util import load_lisp


class Level:

    def __init__(self, *params):
        self.version = 2
        self.filename = None
        self.name = "No Name"
        self.author = "No Author"
        self.theme = "antarctica"
        self.music = ""

        if len(params) == 2:
            # New Level
            width, height = params

            self.width = width
            self.height = height

            self.current_sector = Sector(self)
            self.current_sector.new_from_size("main", width, height)
            self.sectors = []
            self.sectors.push(self.current_sector)

        elif len(params) == 1:
            # Load Level from file
            self.filename, = params

            tree = load_lisp(self.filename, "supertux-level")
            data = tree[1:]

            self.version = get_value_from_tree(["version", "_"], data, 0)

            print("VERSION:", self.filename, " ",  self.version)

            if self.version == 1:
                self.parse_v1(data)
            else:
                self.parse_v2(data)
        else:
            raise Exception("Wrong arguments for SuperTux::___init__")

    def parse_v2(self, data):
        self.name = get_value_from_tree(["name", "_"], data, "no name")
        self.author = get_value_from_tree(["author", "_"], data, "no author")

        self.current_sector = None
        self.sectors = []
        for sec in sexpr_filter("sector", data):
            sector = Sector(self)
            sector.load_v2(sec)
            self.sectors.push(sector)
            if sector.name == "main":
                self.current_sector = sector

        if self.current_sector is None:
            print("Error: No main sector defined:", self.sectors)
            self.current_sector = self.sectors[0]

    def parse_v1(self, data):
        sector = Sector(self)
        sector.load_v1(data)

        self.sectors = []
        self.sectors.push(sector)
        self.current_sector = sector

        self.name = get_value_from_tree(["name", "_"], data, "no name")
        self.author = get_value_from_tree(["author", "_"], data, "no author")

    def save(self, filename):
        self.save_v2(filename)

    def save_v2(self, filename):
        with open(filename, "w") as f:
            f.write(";; Generated by Flexlay Editor\n" +
                    "(supertux-level\n")
            f.write("  (version 2)\n")
            f.write("  (name   (_ \"%s\"))\n" % self.name)
            f.write("  (author \"%s\")\n" % self.author)

            for sector in self.sectors:
                f.write("  (sector\n")
                sector.save(f)
                f.write("   )\n")

            f.write(" )\n\n;; EOF ;;\n")

    def save_v1(self, filename):
        with open(filename, "w") as f:
            f.write(";; Generated by Flexlay Editor\n" +
                    "(supertux-level\n")
            f.write("  (version 1)\n")
            f.write("  (name   \"%s\")\n" % self.name)
            f.write("  (author \"%s\")\n" % self.author)
            f.write("  (width  %d)\n" % self.width)
            f.write("  (height  %d)\n" % self.height)

            f.write("  (music  \"%s\")\n" % self.music)

            f.write("  (gravity %f)\n" % self.gravity)

            f.write("  (theme \"%s\")\n" % self.theme)

            f.write("  (interactive-tm\n")
            for i in self.interactive.get_data():
                f.write("%d " % i)
            f.write("  )\n\n")

            f.write("  (background-tm\n")
            for i in self.background.get_data():
                f.write("%d " % i)
            f.write("  )\n\n")

            f.write("  (foreground-tm\n")
            for i in self.foreground.get_data():
                f.write("%d " % i)
            f.write("  )\n\n")

            f.write("  (camera\n")
            f.write("    (mode \"autoscroll\")\n")
            f.write("    (path\n")
            for obj in self.objects.get_objects():
                pathnode = obj.get_data()
                if type(pathnode) == PathNode:
                    f.write("     (point (x %d) (y %d) (speed 1))\n" % obj.get_pos().x, obj.get_pos().y)
            f.write("  ))\n\n")

            f.write("  (objects\n")
            for obj in self.objects.get_objects():
                badguy = obj.get_data()
                if type(badguy) == BadGuy:
                    pos = obj.get_pos()
                    if type(badguy) != "resetpoint":
                        f.write("     (%s (x %d) (y %d))\n" % badguy.type, int(pos.x), int(pos.y))
            f.write("  )\n\n")

            f.write("  (reset-points\n")
            for obj in self.objects.get_objects():
                badguy = obj.get_data()
                if type(badguy) == BadGuy:
                    pos = obj.get_pos()
                    if badguy.type == "resetpoint":
                        f.write("     (point (x %d) (y %d))\n" % (pos.x.to_i), pos.y.to_i)
            f.write("  )\n\n")

            f.write(" )\n\n;; EOF ;;\n")

    def activate_sector(self, sectorname, workspace):
        for sec in self.sectors:
            if sec.name == sectorname:
                sec.activate(workspace)
                self.current_sector = sec
                break

    def activate(self, workspace):
        self.current_sector.activate(workspace)

    def add_sector(self, sector):
        self.sectors.push(sector)

    def remove_sector(self, name):
        if len(self.sectors) > 1:
            self.sectors = [sec for sec in self.sectors if sec.name != name]
        else:
            print("Only one sector left, can't delete it")

    def get_sectors(self):
        return [sec.name for sec in self.sectors]


# EOF #
